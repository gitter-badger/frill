<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/core/Dispatcher.js | FrillJS API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/nanopx/frill" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/core/Action.js~Action.html">Action</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/core/Context.js~Context.html">Context</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/core/Dispatcher.js~Dispatcher.html">Dispatcher</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/core/Store.js~Store.html">Store</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/actions/Test.js~TestAction.html">TestAction</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/stores/Test.js~TestStore.html">TestStore</a></span></li>
</ul>
</div>





<div data-ice="variableWrap">
  <h2><a href="variable/">Variable</a></h2>
  <ul>
    
  <li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-action">action</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-apiPlugin">apiPlugin</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-context">context</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-store">store</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-testAction">testAction</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-testStore">testStore</a></span></li>
</ul>
</div>




</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/Dispatcher.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">import _clone from &apos;lodash/lang/clone&apos;;
import _isArray from &apos;lodash/lang/isArray&apos;;
import _mapValues from &apos;lodash/object/mapValues&apos;;
import _forOwn from &apos;lodash/object/forOwn&apos;;
import _intersection from &apos;lodash/array/intersection&apos;;
import _keys from &apos;lodash/object/keys&apos;;
import _map from &apos;lodash/collection/map&apos;;
import _each from &apos;lodash/collection/forEach&apos;;
import _size from &apos;lodash/collection/size&apos;;
import _findKey from &apos;lodash/object/findKey&apos;;
import _uniq from &apos;lodash/array/uniq&apos;;

const defaultDispatchInterceptor = (action, dispatch) =&gt; {
  dispatch(action);
  // return {dispatch, action};
};

export default class Dispatcher {

  constructor(stores) {
    this.stores = {};
    this.currentDispatch = null;
    this.currentActionType = null;
    this.waitingToDispatch = [];
    this.dispatchInterceptor = defaultDispatchInterceptor;
    this._boundDispatch = this._dispatch.bind(this);
    _each(stores, (key) =&gt; {
      if (stores[key]) {
        this.addStore(key, stores[key]);
      }
    });

  }

  addStore(name, store) {
    store.dispatcher = this;
    this.stores[name] = store;
  }

  dispatch(action) {
    this.dispatchInterceptor(action, this._boundDispatch);
  }

  _dispatch(action) {

    if (!action || !action.type) {
      throw new Error(&apos;Can only dispatch actions with a \&apos;type\&apos; property&apos;);
    }

    if (this.currentDispatch) {
      const complaint = `Cannot dispatch an action (&apos;${action.type}&apos;) while` +
        ` another action (&apos;${this.currentActionType}&apos;) is being dispatched`;
      throw new Error(complaint);
    }

    this.waitingToDispatch = _clone(this.stores);
    this.currentActionType = action.type;

    this.currentDispatch = _mapValues(this.stores, () =&gt; {
      return {
        resolved: false,
        waitingOn: [],
        waitCallback: null,
      };
    });

    try {
      this.doDispatchLoop(action);
    } finally {
      this.currentActionType = null;
      this.currentDispatch = null;
    }
  }

  doDispatchLoop(action) {
    let wasHandled = false;
    let removeFromDispatchQueue = [];
    let dispatchedThisLoop = [];
    let dispatch;
    let canBeDispatchedTo;

    _forOwn(this.waitingToDispatch, (value, key) =&gt; {
      dispatch = this.currentDispatch[key];
      canBeDispatchedTo = !dispatch.waitingOn.length ||
        !_intersection(dispatch.waitingOn, _keys(this.waitingToDispatch)).length;

      if (canBeDispatchedTo) {

        if (dispatch.waitCallback) {
          stores = _map(dispatch.waitingOn, (key) =&gt; {
            return this.stores[key];
          });

          const fn = dispatch.waitCallback;
          dispatch.waitCallback = null;
          dispatch.waitingOn = [];
          dispatch.resolved = true;
          fn.apply(null, stores);
          wasHandled = true;

        } else {

          dispatch.resolved = true;

          const handled = this.stores[key].__handleAction__(action);

          if (handled) {
            wasHandled = true;
          }
        }
        dispatchedThisLoop.push(key);

        if (this.currentDispatch[key].resolved) {
          removeFromDispatchQueue.push(key);
        }

      }


    });

    if (_keys(this.waitingToDispatch).length &amp;&amp; !dispatchedThisLoop.length) {
      const storesWithCircularWaits = _keys(this.waitingToDispatch).join(&apos;, &apos;);
      throw new Error(`Indirect circular wait detected among: ${storesWithCircularWaits}`);
    }

    _each(removeFromDispatchQueue, (key) =&gt; {
      delete this.waitingToDispatch[key];
    });

    if (_size(this.waitingToDispatch)) {
      this.doDispatchLoop(action);
    }

    if (!wasHandled &amp;&amp; console &amp;&amp; console.warn) {
      console.warn(`An action of type ${action.type} was dispatched, but no store handled it`);
    }
  }

  waitForStores(store, stores, fn) {

    if (!this.currentDispatch) {
      throw new Error(&apos;Cannot wait unless an action is being dispatched&apos;);
    }

    const waitingStoreName = _findKey(this.stores, (val) =&gt; {
      return val == store;
    });

    if (stores.indexOf(waitingStoreName) &gt; -1) {
      throw new Error(&apos;A store cannot wait on itself&apos;);
    }

    const dispatch = this.currentDispatch[waitingStoreName];

    if (dispatch.waitingOn.length) {
      throw new Error(`${waitingStoreName} already waiting on stores`);
    }

    if (!_isArray(stores)) {
      stores = [stores];
    }

    _each(stores, (storeName) =&gt; {
      const storeDispatch = this.currentDispatch[storeName];

      if (!this.stores[storeName]) {
        throw new Error(`Cannot wait for non-existent store ${storeName}`);
      }

      if (storeDispatch.waitingOn.indexOf(waitingStoreName) &gt; -1) {
        throw new Error(`Circular wait detected between ${waitingStoreName} and ${storeName}`);
      }

    });

    dispatch.resolved = false;
    dispatch.waitingOn = _uniq(dispatch.waitingOn.concat(stores));
    dispatch.waitCallback = fn;
  }

  setDispatchInterceptor(fn) {
    if (fn) {
      this.dispatchInterceptor = fn;
    } else {
      this.dispatchInterceptor = defaultDispatchInterceptor;
    }
  }
}
</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.2.0)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
